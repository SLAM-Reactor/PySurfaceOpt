#!/usr/bin/env python3
import numpy as np
import pysurfaceopt as pys
from simsopt.field.biotsavart import BiotSavart
from pysurfaceopt.surfaceobjectives import ToroidalFlux, MajorRadius
from mpi4py import MPI
from simsopt.geo.surfacexyztensorfourier import SurfaceXYZTensorFourier
from simsopt.geo.curve import curves_to_vtk
comm = MPI.COMM_WORLD
rank = comm.rank


boozer_surface_list, base_curves, base_currents, coils = pys.load_surfaces_in_NCSX(Nt_coils=12, idx_surfaces=[rank], exact=True, time_stamp='1636472072.192064', tol=1e-13)
# you can either fix the current in a single coil or introduce a toroidal flux constraint to prevent
# currents from going to zero.  We do the former here:
base_currents[0].fix_all()

OUT_DIR = 'output_exact'

curves = [c.curve for c in coils]
curves_to_vtk(curves, OUT_DIR + "curves_init")

phi = boozer_surface_list[-1].surface.quadpoints_phi
theta = boozer_surface_list[-1].surface.quadpoints_theta

nphi = len(phi)
ntheta = len(theta)
pointData = {"B_N": np.sum(boozer_surface_list[-1].bs.B().reshape((nphi, ntheta, 3)) * boozer_surface_list[-1].surface.unitnormal(), axis=2)[:, :, None]}
boozer_surface_list[-1].surface.to_vtk(OUT_DIR + "surf_init", extra_data=pointData)

B = boozer_surface_list[-1].bs.B().reshape((nphi, ntheta, 3))
B2 = np.sum(B**2, axis=2)
import matplotlib.pyplot as plt
plt.figure()
plt.contourf(phi,theta,B2.T,50)
plt.xlabel(r'$\zeta$')
plt.ylabel(r'$\theta$')
plt.title('modB')
plt.colorbar()
plt.savefig('modB_init.png')

############################################################################
## SET THE TARGET IOTAS, MAJOR RADIUS, TOROIDAL FLUX                      ##
############################################################################

iotas_target = [None for bs in boozer_surface_list]
mr_target   = [None for bs in boozer_surface_list]
J_inner_radius = MajorRadius(boozer_surface_list[0])

if comm.size > 1:
    if rank == 0:
        mr_target[0] = J_inner_radius.J()
        iotas_target[0] = boozer_surface_list[0].res['iota']
    if rank == comm.size-1:
        iotas_target[-1] = -3./7.
else:
    mr_target[0] = J_inner_radius.J()
    iotas_target[0] = boozer_surface_list[0].res['iota']
    iotas_target[-1] = -3./7.

############################################################################
## SET THE INITIAL WEIGHTS, TARGET CURVATURE AND TARGET TOTAL COIL LENGTH ##
############################################################################

KAPPA_MAX = 5.
KAPPA_WEIGHT = 1e-9

MSC_MAX = 5.
MSC_WEIGHT = 1e-9

LENGTHBOUND = 20.8
LENGTHBOUND_WEIGHT = 1e-9

MIN_DIST = 0.15
MIN_DIST_WEIGHT = 1e-3

ALEN_WEIGHT = 1e-4

IOTAS_TARGET_WEIGHT = 1.
MR_WEIGHT = 1.
RES_WEIGHT = 1e-3

problem = pys.SurfaceProblem(boozer_surface_list, base_curves, base_currents, coils,
                             iotas_target=iotas_target, major_radii_targets=mr_target,
                             iotas_target_weight=IOTAS_TARGET_WEIGHT, mr_weight=MR_WEIGHT,
                             minimum_distance=MIN_DIST, kappa_max=KAPPA_MAX, lengthbound_threshold=LENGTHBOUND,
                             msc_max=MSC_MAX, msc_weight=MSC_WEIGHT,
                             distance_weight=MIN_DIST_WEIGHT, curvature_weight=KAPPA_WEIGHT, lengthbound_weight=LENGTHBOUND_WEIGHT, arclength_weight=ALEN_WEIGHT,
                             residual_weight=RES_WEIGHT,
                             rank=rank, outdir_append="exact",axis=1)


coeffs = problem.x.copy()
problem.callback(coeffs)

def J_scipy(dofs,*args):
    problem.x = dofs
    J = problem.res
    dJ = problem.dres
    return J, dJ

from scipy.optimize import minimize
res = minimize(J_scipy, coeffs, jac=True, method='bfgs', tol=1e-20, callback=problem.callback)
if rank == 0:
    print(f"{res['success']}, {res['message']}")

nphi = 100
ntheta = 100
surfold = boozer_surface_list[-1].surface
phi = np.linspace(0,1/surfold.nfp,nphi)
theta = np.linspace(0,1,ntheta)
bs = boozer_surface_list[-1].bs
surf = SurfaceXYZTensorFourier(mpol=surfold.mpol, ntor=surfold.ntor,
        stellsym=surfold.stellsym, nfp=surfold.nfp, quadpoints_phi=phi,
        quadpoints_theta=theta)
surf.set_dofs(surfold.get_dofs())
x = surf.gamma()
xsemiflat = x.reshape((x.size//3, 3)).copy()
bs.set_points(xsemiflat)

curves = [c.curve for c in coils]
curves_to_vtk(curves, OUT_DIR + "curves_final")
pointData = {"B_N": np.sum(bs.B().reshape((nphi, ntheta, 3)) * surf.unitnormal(), axis=2)[:, :, None]}
surf.to_vtk(OUT_DIR + "surf_final", extra_data=pointData)

B = bs.B().reshape((nphi, ntheta, 3))
B2 = np.sum(B**2, axis=2)
import matplotlib.pyplot as plt
plt.figure()
plt.contourf(phi,theta,B2.T,50)
plt.xlabel(r'$\zeta/(2\pi/N_P)$')
plt.ylabel(r'$\theta/(2\pi)$')
plt.title('modB')
plt.colorbar()
plt.savefig('modB_final.png')
